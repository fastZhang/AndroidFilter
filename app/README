###Android滤镜开发（一） 开篇：关于滤镜

**滤镜**

一般是由玻璃，树脂和聚碳酸酯等制成的物体，
用来处理相机等传感器受到外界环境的影响，或者达到某种效果。
对于现在数字时代的图像作品，我们可以通过算法处理来达到以前镜片的效果。

**Android平台上的滤镜开发**
1. 所谓滤镜处理，在Android上有以下几个维度和层面上的处理

    java层，Bitmap像素点和矩阵操作；ColorMatrix等系统api
    native层，使用c/c++本地语言，具有更高的性能，可操作java层传入的Bitmap数据
    
    整体处理，即对整个图片处理，矩阵处理，ColorMatrix或者系统api
    特殊像素点的单个或局部处理
   
    cpu处理，上述处理都是基于cpu的，cpu计算能力强，但核心少，并行差
    gpu处理，核心多，并行强。Android系统上使用opengl es来调用gpu加速，并行处理图像
    
2. 对于opengl，我们可以查阅相关资料，能做的事情，并不限于滤镜。
    他的核心工作方式，是几乎可以并行的处理图像像素点，而cpu只能串行的处理像素点
    
3. 所以gpu处理，性能更好，更快。对于静态图像上，进行简单的滤镜处理，cpu方式还是可以胜任的。
    但对于相机滤镜和视频动态滤镜时，cpu可能出现明显的卡顿现象，这时就需要进行gpu滤镜处理，
    且能以胜任
    
4. 滤镜处理图像的方式和思想在移动平台上有很多应用，比如图片滤镜，美颜美妆相机，动态贴纸，
    视频特效等
    
5. 对于各种应用特效的实现方案，通常是，像素判断，整体像素判断处理，mask辅助图，
    各种图像处理学算法，颜色空间转换等
    

6. 对与cpu的各种处理方式，我们通过Bitmap或者系统api，来进行各种滤镜算法的实现是比较简单的，
    这里，将重点gpu的处理方式
    
    

**相机数据的处理方式**（来自互联网）
    

1. 不转换，直接由OpenGL绘制，采用Shader实现图像处理（因处理算法和渲染图片大部分
采用RGB格式，此方案暂不考虑，仅提出可能性）；

2. 通过C/C++实现YUV->RGB和图像处理，合成Bitmap，由CPU绘制在Canvas上；

3. 通过C/C++实现YUV->RGB和图像处理，在NDK层直接绘制在SurfaceView上；

4. 通过C/C++实现YUV->RGB，采用Shader实现图像处理，采用OpenGL绘制（android-gpuimage）；

5. 通过Shader实现YUV->RGB和图像处理，采用OpenGL绘制。
    
**应用**

1. 图片：对于一个图片，我们可以根据所需效果，依据上述方法进行各种处理

2. 视频：视频处理依据视频的来源，
    第一种是通过相机获取视频数据，通常是YUV格式，然后逐帧对其处理；
    第二种是，通过一张或多张素材图片，来进行滤镜处理，如转场，动画，幻灯片类似的处理，然后生成视频；
    第三种是，用户输入的源视频，通过MediaDecoder或者FFmpeg来获取视频帧处理
    注意：视频对帧率要求较高，不能出现卡顿
    
    
3. 相机滤镜：YUV视频数逐帧处理
    
    
4. 美颜美妆：
    对于单张静态图片，通过人脸识别，进行区域判断，进行美妆，上色等
    对于相机：通过对YUV视频数逐帧进行人脸识别，然后处理
    
5. 人脸动态贴纸：和美颜美妆处理方式相同


6. ........其它应用


**关于人脸识别方案**
* 自己也能实现简单的人脸识别，但精度和速度，对于生产环境很苛刻，通常是购买三方服务。
    好在这些三方服务，目前有免费测试用，不过发布到应用市场，或其他商业应用，都需要购买了，
    这些识别以sdk的方式集成到apk包中，按时或者按次收费
    
    
###Android滤镜开发（二）Bitmap的图像和像素操作

   
    

    